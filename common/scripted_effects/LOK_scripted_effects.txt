calculate_food_consumption_in_state = { #By default 100k people eat one food per month. Can be modified by some species (eg Paluush).
	if = {
		limit = { state_eats_food = yes }
		set_variable = { state_food_consumption = state_population_k }
		divide_variable = { state_food_consumption = 100 }
		if = { #Katzens and Sobakis are mostly carnivorous and thus eat 15% more
			limit = {
				OR = {
					check_variable = { species = 1 }
					check_variable = { species = 2 }
				}
			}
			multiply_variable = { state_food_consumption = 1.15 }
		}
		round_variable = state_food_consumption
	}
}

calculate_food_production_in_state = {
	set_variable = { state_food_production = resource@food }
}

calculate_total_food_consumption = {
	set_variable = { country_food_stockpile_max = 0 } #reset food stockpile capacity
	set_variable = { country_food_consumption = 0 } #Food that is being eaten
	set_variable = { country_food_balance = resource_produced@food } #Total food balance
	set_variable = { country_food_imports = resource_imported@food } #Imports
	add_to_variable = { country_food_balance = country_food_imports } #Total food balance (with imports)
	every_controlled_state = { #Fetch how much food each state eats.
		calculate_food_consumption_in_state = yes
		ROOT = {
			add_to_variable = { country_food_consumption = PREV.state_food_consumption }

			set_variable = { country_food_stockpile_from_infra = PREV.non_damaged_building_level@infrastructure }
			multiply_variable = { country_food_stockpile_from_infra = 10 } #1 infra = 10 food or 10M people for 1 month
			add_to_variable = { country_food_stockpile_max = country_food_stockpile_from_infra }

			set_variable = { country_food_stockpile_from_silos = PREV.non_damaged_building_level@food_silo }
			multiply_variable = { country_food_stockpile_from_silos = 50 } #1 silo = 50 food or 50M people for 1 month
			add_to_variable = { country_food_stockpile_max = country_food_stockpile_from_silos }
		}
	}
	set_variable = { country_food_consumption_modifier = country_food_consumption }
	#multiply_variable = { country_food_consumption_modifier = -1 }
	# set_temp_variable = { negate_exacavation_tech_food = modifier@local_resources_factor } #This is to undo the effects of excavation techs.
	# add_to_temp_variable = { negate_exacavation_tech_food = 1 } #The resource modifier is gonna be something like 0.2 (if you have +20%) so I add 1 to get a proper percentage.
	# divide_variable = { country_food_consumption_modifier = negate_exacavation_tech_food }
	round_variable = country_food_consumption_modifier
	set_variable = { country_food_production = country_food_balance } #The food that we're actually producing
	add_to_variable = { country_food_production = country_food_consumption } #We add our consumption to the balance to get production, yippe!

	#FOOD STOCKPILING

	if = { #If balance is positive put into the stockpile
		limit = { check_variable = { country_food_balance > 0 } }
		set_temp_variable = { country_food_going_into_stockpile = country_food_balance }
		multiply_temp_variable = { country_food_going_into_stockpile = 0.5 } #as the monke said not all food can be put into storage
		add_to_variable = { country_food_stockpile = country_food_going_into_stockpile }
		clamp_variable = {  var = country_food_stockpile max = country_food_stockpile_max } #Cant go over limit
		round_variable = country_food_stockpile
	}
	else_if = { #If balance is negative take from the stockpile if it exists
		limit = { check_variable = { country_food_balance < 0 } check_variable = { country_food_stockpile > 0 } }
		add_to_variable = { country_food_stockpile = country_food_balance }
		clamp_variable = {  var = country_food_stockpile min = 0 } #Cant go below 0
	}

	#CALCULATE % THAT IS MET - This is what determines the actual effects of food deficit
	set_variable = { country_food_needs_met_perc = country_food_production }
	divide_variable = { country_food_needs_met_perc = country_food_consumption }
	if = { #Nekeox and such
		limit = { check_variable = { country_food_consumption = 0 } }
		set_variable = { country_food_needs_met_perc = 1 }
	}
	set_variable = { country_food_needs_modifier = country_food_needs_met_perc } #For the modifier
	multiply_variable = { country_food_needs_met_perc = 100 }
	round_variable = country_food_needs_met_perc

	#MODIFIER
	subtract_from_variable = { country_food_needs_modifier = 1 }
	if = {
		limit = { check_variable = { country_food_needs_met_perc < 100 } check_variable = { country_food_stockpile < 1 } }
		add_dynamic_modifier = { modifier = lok_food_deficit_modifier }
	}
	else_if = {
		limit = { has_dynamic_modifier = { modifier = lok_food_deficit_modifier } }
		remove_dynamic_modifier = { modifier = lok_food_deficit_modifier }
	}

	#IF % MET IS BELOW 61% AND STOCKPILES ARE EMPTY... PEOPLE DIE! 3% of the population will die every week until food goes back above 60%
	if = {
		limit = {
			check_variable = { country_food_needs_met_perc < 61 }
			check_variable = { country_food_stockpile < 1 }
		}
		every_controlled_state = {
			set_variable = { lok_starvation_death_count = state_population_k }
			multiply_variable = { lok_starvation_death_count = 0.03 } #3% of the pop perishes
			round_variable = lok_starvation_death_count

			#Variable shenanigans to bypass overflow issues
			set_temp_variable = { lok_starvation_death_count_divided_10 = lok_starvation_death_count }
			multiply_temp_variable = { lok_starvation_death_count_divided_10 = -100 } #Divide by 10 and multiply by 1000 to get chunks that are equal to 1/10ths of the final casualty count - should be below overflow
			for_loop_effect = { #Now do it 10 times
				end = 10
				add_manpower = lok_starvation_death_count_divided_10
			}
			#And of course... the casualty counter
			add_to_variable = { lok_state_starvation_deaths = lok_starvation_death_count }
			add_to_variable = { lok_state_deaths = lok_starvation_death_count }

			var:CONTROLLER = {
				add_to_variable = { lok_country_starvation_deaths = PREV.lok_starvation_death_count }
				add_to_variable = { lok_country_deaths = PREV.lok_starvation_death_count }
				add_to_variable = { global.lok_global_starvation_deaths = PREV.lok_starvation_death_count }
				add_to_variable = { global.lok_global_deaths = PREV.lok_starvation_death_count }
			}
		}
	}
}

#Stab/WS hit from noncore states to encourage puppeting
calculate_stab_ws_hit_from_noncore = {
	set_variable = { stab_from_noncore = 0 }
	set_variable = { ws_from_noncore = 0 }
	every_owned_state = {
		if = { #All noncore states remove 1% from WS and STAB
			limit = { NOT = { is_core_of = ROOT } }
			ROOT = {
				subtract_from_variable = { stab_from_noncore = 0.01 }
				subtract_from_variable = { ws_from_noncore = 0.01 }
			}
			if = { #Claims negate the hit a bit
				limit = { is_claimed_by = ROOT }
				ROOT = {
					add_to_variable = { stab_from_noncore = 0.005 }
					add_to_variable = { ws_from_noncore = 0.005 }
				}
			}
		}
	}
	set_variable = { stab_from_noncore_display = stab_from_noncore }
	multiply_variable = { stab_from_noncore_display = -100 }
	set_variable = { ws_from_noncore_display = ws_from_noncore }
	multiply_variable = { ws_from_noncore_display = -100 }
}

calculate_combat_casualties = {
	#Get thousands of casualties and divide by 1000 for millions
	if = {
		limit = { casualties_k > 0 }
		set_variable = { lok_country_combat_deaths_last_week = casualties_k } #Get total casualties
		#divide_temp_variable = { lok_country_combat_deaths_last_week = 1000 } #Turn to millions
		subtract_from_variable = { lok_country_combat_deaths_last_week = lok_country_combat_deaths } #Remove those that we have already counted
		clamp_variable = { var = lok_country_combat_deaths_last_week min = 0 } #Avoid negative casualties if something goes wrong
		#round_temp_variable = lok_country_combat_deaths_last_week

		#Add that to the various trackers
		add_to_variable = { lok_country_combat_deaths = lok_country_combat_deaths_last_week } #Add the difference to the current total, getting the current total country combat deaths
		add_to_variable = { lok_country_deaths = lok_country_combat_deaths_last_week } #Also add it to the grand total
		add_to_variable = { global.lok_global_combat_deaths = lok_country_combat_deaths_last_week } #Add the last week difference to the global combat counter as well
		add_to_variable = { global.lok_global_deaths = lok_country_combat_deaths_last_week } #Add the last week difference to the global counter as well
	
		set_variable = { lok_country_combat_deaths_last_week_2 = lok_country_combat_deaths_last_week }

		#Depopulate states with these losses
		if = {
			limit = { check_variable = { lok_country_combat_deaths_last_week_2 > 0 } }
			multiply_variable = { lok_country_combat_deaths_last_week_2 = 1000 }
			# #Overall, 90% of casualties will come from cores, 10% will come from noncore. Approximation but good enough for now.
			# set_temp_variable = { lok_core_combat_deaths = lok_country_combat_deaths_last_week }
			# multiply_temp_variable = { lok_core_combat_deaths = 0.90 }
			# set_temp_variable = { lok_num_core_states = 0 }
			# every_controlled_state = { #Count core states
			# 	limit = { is_core_of = ROOT }
			# 	PREV = { add_to_temp_variable = { lok_num_core_states = 1 } }
			# }
			# divide_temp_variable = { lok_core_combat_deaths = lok_num_core_states } #The amount of deaths in each state more or less
			every_controlled_state = {
				set_temp_variable = { lok_combat_deaths_percent_for_state = state_population_k }
				divide_temp_variable = { lok_combat_deaths_percent_for_state = ROOT.max_manpower_k }
				clamp_temp_variable = {
					var = lok_combat_deaths_percent_for_state
					min = 0.001
				}
				set_temp_variable = { lok_combat_deaths_to_be_removed_for_state = ROOT.lok_country_combat_deaths_last_week_2 }
				multiply_temp_variable = { lok_combat_deaths_to_be_removed_for_state = lok_combat_deaths_percent_for_state }
				round_temp_variable = lok_combat_deaths_to_be_removed_for_state

				multiply_temp_variable = { lok_combat_deaths_to_be_removed_for_state = -1 }
				add_manpower = lok_combat_deaths_to_be_removed_for_state

				divide_temp_variable = { lok_combat_deaths_to_be_removed_for_state = -1000 }
				add_to_variable = { lok_state_combat_deaths = lok_combat_deaths_to_be_removed_for_state }
				add_to_variable = { lok_state_deaths = lok_combat_deaths_to_be_removed_for_state }
			}
		}
	}
}

fire_thermonuclear_salvo = {
	for_loop_effect = {
		end = 20
		event_target:lok_thermonuclear_salvo_state = {
			set_temp_variable = { anti_wmd_level = building_level@anti_wmd }
			multiply_temp_variable = { anti_wmd_level = 18 }
			set_temp_variable = { anti_wmd_level_negative = anti_wmd_level }
			multiply_temp_variable = { anti_wmd_level_negative = -1 }
		}
		random_list = {
			100 = {
				launch_nuke = { state = event_target:lok_thermonuclear_salvo_state use_nuke = no }
				event_target:lok_thermonuclear_salvo_state = {
					add_to_variable = { lok_radiation_level = 0.33 }
				}
				modifier = { add = event_target:lok_thermonuclear_salvo_state.anti_wmd_level_negative }
			}
			0 = {
				modifier = { add = event_target:lok_thermonuclear_salvo_state.anti_wmd_level }
			}
		}
	}
}

collapse_into_anarchy = {
	transfer_state_to = AAA
	set_demilitarized_zone = yes
}

#weekly check to reduce and spread radiation
calculate_radiation_in_state = {
	if = {
		limit = { check_variable = { lok_radiation_level > 0 } }
		if = { #Below 0.2 it just goes away
			limit = { check_variable = { lok_radiation_level < 0.2 } }
			set_variable = { lok_radiation_level = 0 }
		}
		#Collapse into anarchy if radiation gets high enough
		if = {
			limit = { check_variable = { lok_radiation_level > 50 } }
			collapse_into_anarchy = yes
		}
		multiply_variable = { lok_radiation_level = 0.75 } #Half life of one week
		clamp_variable = { var = lok_radiation_level min = 0 }
		#Random spread to neighboring states: every week there is a 50% chance that a neighboring state get contaminated with half of the fallout.
		set_variable = { lok_radiation_spread = lok_radiation_level }
		multiply_variable = { lok_radiation_spread = 0.50 }
		random_neighbor_state = {
			random_list = {
				50 = {
					add_to_variable = { var = lok_radiation_level value = PREV.lok_radiation_spread }
					PREV = { subtract_from_variable = lok_radiation_spread }
				}
				50 = {}
			}
		}
	}
}

#applied immediately when radiation is added - debuffs the state
calculate_radiation_state_modifiers = {
	#Apply radiation state modifiers. Calculated as a percentage, with 10 radiation = -100% to all.
	set_variable = { lok_radiation_modifier = lok_radiation_level } #Say 5
	#Species Effects THIS IS THE "EFFECTS FROM RADIATION" TRAIT
	if = {
		limit = { check_variable = { species = 1 } } #-30% for Katzens
		multiply_variable = { lok_radiation_modifier = 0.7 }
	}
	if = {
		limit = { #-75% for Lithoids
			OR = {
				check_variable = { species = 5 }
				check_variable = { species = 8 }		
			}
		} 
		multiply_variable = { lok_radiation_modifier = 0.25 }
	}
	divide_variable = { lok_radiation_modifier = 10 } #Now 0.5
	clamp_variable = { var = lok_radiation_modifier min = 0 max = 0.9 } #Clamp between 0 and 0.9
	multiply_variable = { lok_radiation_modifier = -1 } #Make negative
}

#applied weekly, kill people due to radiation
apply_radiation_effects = {
	if = { #Kill people in the state
		limit = { #THIS IS THE "BASE RADIATION RESISTANCE TRAIT"
			NOT = {
				AND = { check_variable = { species = 1 } check_variable = { lok_radiation_level < 0.8 } } #Katzens don't die below 0.8 radiation
				AND = {
					OR = { check_variable = { species = 5 } check_variable = { species = 8 } }
					check_variable = { lok_radiation_level < 5 } #NMI + Nekeox don't die below 5
				}
			}
		}
		#Kill people in the state (RIP Bozo)
		set_variable = { lok_radiation_death_percent = lok_radiation_level }
		#Every level of radiation kills %, so 10 radiation = 10% death (Or 0.02)
		divide_variable = { lok_radiation_death_percent = 100 }

		#THIS IS THE "CASUALTIES FROM RADIATION" TRAIT
		if = {
			limit = { check_variable = { species = 1 } } #Only half the deaths for Katzen states
			multiply_variable = { lok_radiation_death_percent = 0.5 }
		}

		if = {
			limit = { #-75% for Lithoids
				OR = { check_variable = { species = 5 } check_variable = { species = 8 } }
			} 
			multiply_variable = { lok_radiation_death_percent = 0.25 }
		}

		set_variable = { lok_radiation_death_count = state_population_k }
		multiply_variable = { lok_radiation_death_count = lok_radiation_death_percent }
		clamp_variable = { var = lok_radiation_death_count min = 0 max = 2000 } #Avoid overflow
		multiply_variable = { lok_radiation_death_count = -1000 } #Turn to raw manpower
		add_manpower = lok_radiation_death_count #Remove the people
		divide_variable = { lok_radiation_death_count = -1000 } #Turn back to positive and divide by 1000 for tracking

		#Add to the trackers
		add_to_variable = { lok_state_radiation_deaths = lok_radiation_death_count }
		add_to_variable = { lok_state_deaths = lok_radiation_death_count }

		var:CONTROLLER = {
			add_to_variable = { lok_country_radiation_deaths = PREV.lok_radiation_death_count }
			add_to_variable = { lok_country_deaths = PREV.lok_radiation_death_count }
			add_to_variable = { global.lok_global_radiation_deaths = PREV.lok_radiation_death_count }
			add_to_variable = { global.lok_global_deaths = PREV.lok_radiation_death_count }
		}
	}
}

apply_state_species_modifier = {
	if = {
		limit = { has_dynamic_modifier = { modifier = lok_species_katzen_majority } }
		remove_dynamic_modifier = { modifier = lok_species_katzen_majority }
	}
	if = {
		limit = { has_dynamic_modifier = { modifier = lok_species_sobaki_majority } }
		remove_dynamic_modifier = { modifier = lok_species_sobaki_majority }
	}
	if = {
		limit = { check_variable = { species = 1 } }
		add_dynamic_modifier = { modifier = lok_species_katzen_majority }
	}
	if = {
		limit = { check_variable = { species = 2 } }
		add_dynamic_modifier = { modifier = lok_species_sobaki_majority }
	}
}

clear_wonder_ideas = {
	# remove_idea = wonder_idea_1_normal
	# remove_idea = wonder_idea_1_capital
	# remove_idea = wonder_idea_1_noncore
	# remove_idea = wonder_idea_2_normal
	# remove_idea = wonder_idea_2_capital
	# remove_idea = wonder_idea_2_noncore
	# remove_idea = wonder_idea_3_normal
	# remove_idea = wonder_idea_3_capital
	# remove_idea = wonder_idea_3_noncore
	# remove_idea = wonder_idea_4_normal
	# remove_idea = wonder_idea_4_capital
	# remove_idea = wonder_idea_4_noncore
	set_variable = { wonder_idea_removed_number = 1 }
	while_loop_effect = {
		limit = { check_variable = { wonder_idea_removed_number < 10 } }
		add_to_variable = { wonder_idea_removed_number = 1 }
		meta_effect = {
			text = {
				if = {
					limit = { has_idea = wonder_idea_[WONDER_ID]_normal }
					remove_ideas = wonder_idea_[WONDER_ID]_normal
				}
				if = {
					limit = { has_idea = wonder_idea_[WONDER_ID]_capital }
					remove_ideas = wonder_idea_[WONDER_ID]_capital
				}
				if = {
					limit = { has_idea = wonder_idea_[WONDER_ID]_noncore }
					remove_ideas = wonder_idea_[WONDER_ID]_noncore
				}
			}
			WONDER_ID = "[?ROOT.wonder_idea_removed_number]"
		}
	}
}

apply_wonder_effects = {
	# every_controlled_state = {
	# 	if = {
	# 		limit = { check_variable = { wonder > 0 } }
	# 		for_each_loop = { #We interate through the modifier values array and use the various values to generate the variables
	# 			array = wonder_modifiers_values
	# 			value = v
	# 			index = i
	# 			break = break
	# 			set_variable = { wonder_modifier_id = i }
	# 			set_variable = { wonder_modifier_value = v }
	# 			meta_effect = {
	# 				debug = yes
	# 				text = {
	# 					set_variable = { wonder_[WONDER_ID]_modifier_[WONDER_MODIFIER_ID] = [WONDER_MODIFIER_VALUE] }
	# 					if = {
	# 						limit = { is_capital = yes }
	# 						multiply_variable = { wonder_[WONDER_ID]_modifier_[WONDER_MODIFIER_ID] = 2 }
	# 					}
	# 					else_if = {
	# 						limit = { NOT = { is_core_of = var:controller } }
	# 						multiply_variable = { wonder_[WONDER_ID]_modifier_[WONDER_MODIFIER_ID] = 0.5 }
	# 					}
	# 					var:controller = {
	# 						set_variable = { wonder_[WONDER_ID]_modifier_[WONDER_MODIFIER_ID] = PREV.wonder_[WONDER_ID]_modifier_[WONDER_MODIFIER_ID] }
	# 					}
	# 				}
	# 				WONDER_ID = "[?wonder]"
	# 				WONDER_MODIFIER_ID = "[?wonder_modifier_id]"
	# 				WONDER_MODIFIER_VALUE = "[?wonder_modifier_value]"
	# 			}
	# 		}
	# 	}
	# }


	clear_wonder_ideas = yes
	every_controlled_state = {
		if = {
			limit = { check_variable = { wonder > 0 } }
			if = {
				limit = { is_capital = yes }
				var:controller = {
					meta_effect = {
						text = { add_ideas = wonder_idea_[WONDER_ID]_capital }
						WONDER_ID = "[?PREV.wonder]"
					}
				}
			}
			else_if = {
				limit = { is_core_of = ROOT }
				var:controller = {
					meta_effect = {
						text = { add_ideas = wonder_idea_[WONDER_ID]_normal }
						WONDER_ID = "[?PREV.wonder]"
					}
				}
			}
			else = {
				var:controller = {
					meta_effect = {
						text = { add_ideas = wonder_idea_[WONDER_ID]_noncore }
						WONDER_ID = "[?PREV.wonder]"
					}
				}
			}
		}
	}
	# if = {
	# 	limit = { controls_state = 509 }
	# 	if = {
	# 		limit = { 509 = { is_capital = yes } }
			
	# 	}
	# 	else_if = {
	# 		limit = { 509 = { is_core_of = ROOT } }
	# 		add_ideas = wonder_idea_1_normal
	# 	}
	# 	else = { add_ideas = wonder_idea_1_noncore }
	# }
	# if = {
	# 	limit = { controls_state = 173 }
	# 	if = {
	# 		limit = { 173 = { is_capital = yes } }
	# 		add_ideas = wonder_idea_2_capital
	# 	}
	# 	else_if = {
	# 		limit = { 173 = { is_core_of = ROOT } }
	# 		add_ideas = wonder_idea_2_normal
	# 	}
	# 	else = { add_ideas = wonder_idea_2_noncore }
	# }
	# if = {
	# 	limit = { controls_state = 116 }
	# 	if = {
	# 		limit = { 116 = { is_capital = yes } }
	# 		add_ideas = wonder_idea_3_capital
	# 	}
	# 	else_if = {
	# 		limit = { 116 = { is_core_of = ROOT } }
	# 		add_ideas = wonder_idea_3_normal
	# 	}
	# 	else = { add_ideas = wonder_idea_3_noncore }
	# }
	# if = {
	# 	limit = { controls_state = 220 }
	# 	if = {
	# 		limit = { 220 = { is_capital = yes } }
	# 		add_ideas = wonder_idea_4_capital
	# 	}
	# 	else_if = {
	# 		limit = { 220 = { is_core_of = ROOT } }
	# 		add_ideas = wonder_idea_4_normal
	# 	}
	# 	else = { add_ideas = wonder_idea_4_noncore }
	# }
}